#include <iostream>
#include <chrono>
#include <vector>
#include <string>
#include <functional>
#include <iomanip>

// image io
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

// fast blur
#include "fast_gaussian_blur_template.h"

typedef unsigned char uchar;

// Benchmark function type
using BenchmarkFunction = std::function<void(const std::string&, const std::string&, float, int, const std::string&)>;

// #define USE_FLOAT

// Improved version of the blur implementation
namespace improved {

// Add SIMD optimization for horizontal blur functions
template<typename T, int C, Kernel kernel = kSmall>
inline void horizontal_blur_extend(const T* in, T* out, const int w, const int h, const int r)
{
    // change the local variable types depending on the template type for faster calculations
    using calc_type = std::conditional_t<std::is_integral_v<T>, int, float>;

    const float iarr = 1.f / (r+r+1);
    #pragma omp parallel for schedule(dynamic, 16)
    for(int i=0; i<h; i++) 
    {
        const int begin = i*w;
        const int end = begin+w;
        calc_type fv[C], lv[C], acc[C];                 // first value, last value, sliding accumulator

        // init fv, lv, acc by extending outside the image buffer
        for(int ch=0; ch<C; ++ch)
        {
            fv[ch] = in[begin*C+ch];
            lv[ch] = in[(end-1)*C+ch];
            acc[ch] = (r+1)*fv[ch];
        }

        if constexpr(kernel == kLarge)
        {
            // initial acucmulation - vectorize this loop
            #pragma omp simd
            for(int j=0; j<r; j++)
            for(int ch=0; ch<C; ++ch)
            {
                acc[ch] += j < w ? in[(begin+j)*C+ch] : lv[ch];
            }

            // Vectorize the main loop
            #pragma omp simd
            for(int ti = begin; ti < end; ti++)
            for(int ch=0; ch<C; ++ch)
            {
                acc[ch] += lv[ch] - fv[ch];
                out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
            }
        }
        else if constexpr(kernel == kMid)
        {
            // current index, left index, right index
            int ti = begin, li = begin-r-1, ri = begin+r;
            
            // Vectorize initial accumulation
            #pragma omp simd
            for(int j=ti; j<ri; j++)
            for(int ch=0; ch<C; ++ch)
            {
                acc[ch] += in[j*C+ch];
            }

            // Use prefetching for the main loops
            // 1. left side out and right side in
            for(; ri<end; ri++, ti++, li++)
            {
                __builtin_prefetch(&in[ri*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&out[ti*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch)
                {
                    acc[ch] += in[ri*C+ch] - fv[ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }

            // 4. left side out and right side out
            for(; li<begin; ti++, li++)
            {
                __builtin_prefetch(&out[ti*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch)
                {
                    acc[ch] += lv[ch] - fv[ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }

            // 3. left side in and right side out
            for(; ti<end; ti++, li++)
            {
                __builtin_prefetch(&in[li*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&out[ti*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch)
                {
                    acc[ch] += lv[ch] - in[li*C+ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }
        }
        else if constexpr(kernel == kSmall)
        {
            // current index, left index, right index
            int ti = begin, li = begin-r-1, ri = begin+r;

            // Vectorize initial accumulation
            #pragma omp simd
            for(int j=ti; j<ri; j++)
            for(int ch=0; ch<C; ++ch)
            {
                acc[ch] += in[j*C+ch];
            }

            // Use prefetching and loop unrolling for the main loops
            // 1. left side out and right side in
            for(; li<begin; ri++, ti++, li++)
            {
                __builtin_prefetch(&in[ri*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&out[ti*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch)
                {
                    acc[ch] += in[ri*C+ch] - fv[ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }

            // 2. left side in and right side in - most common case, optimize the most
            // Use loop unrolling for performance
            int remaining = end - ri;
            int unroll_count = remaining / 4;
            int leftover = remaining % 4;
            
            // Process 4 pixels at a time
            for(int u = 0; u < unroll_count; u++) {
                __builtin_prefetch(&in[(ri+4)*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&in[(li+4)*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&out[(ti+4)*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch) {
                    // Process 4 pixels in a row
                    acc[ch] += in[ri*C+ch] - in[li*C+ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                    
                    acc[ch] += in[(ri+1)*C+ch] - in[(li+1)*C+ch];
                    out[(ti+1)*C+ch] = acc[ch]*iarr + round_v<T>();
                    
                    acc[ch] += in[(ri+2)*C+ch] - in[(li+2)*C+ch];
                    out[(ti+2)*C+ch] = acc[ch]*iarr + round_v<T>();
                    
                    acc[ch] += in[(ri+3)*C+ch] - in[(li+3)*C+ch];
                    out[(ti+3)*C+ch] = acc[ch]*iarr + round_v<T>();
                }
                
                ri += 4; ti += 4; li += 4;
            }
            
            // Process remaining pixels
            for(int u = 0; u < leftover; u++, ri++, ti++, li++) {
                for(int ch=0; ch<C; ++ch) {
                    acc[ch] += in[ri*C+ch] - in[li*C+ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }

            // 3. left side in and right side out
            for(; ti<end; ti++, li++)
            {
                __builtin_prefetch(&in[li*C+C*8], 0, 0); // Prefetch read ahead
                __builtin_prefetch(&out[ti*C+C*8], 1, 0); // Prefetch write ahead
                
                for(int ch=0; ch<C; ++ch)
                {
                    acc[ch] += lv[ch] - in[li*C+ch];
                    out[ti*C+ch] = acc[ch]*iarr + round_v<T>();
                }
            }
        }
    }
}

// Optimized flip_block implementation
template<typename T, int C>
inline void flip_block(const T* in, T* out, const int w, const int h)
{
    constexpr int block = 64; // Reduced block size for better cache locality
    
    #pragma omp parallel for collapse(2) schedule(dynamic)
    for(int x = 0; x < w; x += block)
    for(int y = 0; y < h; y += block)
    {
        const int blockx = std::min(block, w - x);
        const int blocky = std::min(block, h - y);
        
        // Process each block with vectorization
        for(int xx = 0; xx < blockx; xx++)
        {
            const T* p = in + (y*w + (x+xx))*C;
            T* q = out + ((x+xx)*h + y)*C;
            
            // Use SIMD for inner loop when possible
            #pragma omp simd
            for(int yy = 0; yy < blocky; yy++)
            {
                for(int k = 0; k < C; k++)
                    q[yy*C + k] = p[yy*w*C + k];
            }
        }
    }
}

// Hook these improved functions into the main algorithm
template<typename T, Border P = kMirror>
void fast_gaussian_blur(
    T*& in,
    T*& out,
    const int w,
    const int h,
    const int c,
    const float sigma,
    const uint32_t n = 3)
{
    // compute box kernel sizes
    int boxes[10]; // Support up to 10 passes
    sigma_to_box_radius(boxes, sigma, n);

    // perform N horizontal blur passes
    for(int i = 0; i < n; ++i)
    {
        if(P == kExtend) {
            // Use our improved horizontal blur
            horizontal_blur_extend<T, 3, kSmall>(in, out, w, h, boxes[i]);
        } else {
            // Use original implementation for other border types
            horizontal_blur<T, P>(in, out, w, h, c, boxes[i]);
        }
        std::swap(in, out);
    }   

    // flip buffer - use our improved flip_block
    if(c <= 4) { // Only use optimized version for standard channel counts
        flip_block<T, 3>(in, out, w, h);
    } else {
        // Use original for other channel counts
        flip_block(in, out, w, h, c);
    }
    std::swap(in, out);
    
    // perform N horizontal blur passes on flipped image
    for(int i = 0; i < n; ++i)
    {
        if(P == kExtend) {
            // Use our improved horizontal blur
            horizontal_blur_extend<T, 3, kSmall>(in, out, h, w, boxes[i]);
        } else {
            // Use original implementation for other border types
            horizontal_blur<T, P>(in, out, h, w, c, boxes[i]);
        }
        std::swap(in, out);
    }   
    
    // flip buffer - use our improved flip_block
    if(c <= 4) { // Only use optimized version for standard channel counts
        flip_block<T, 3>(in, out, h, w);
    } else {
        // Use original for other channel counts
        flip_block(in, out, h, w, c);
    }
    
    // Make sure result is in the out buffer
    if(n % 2 == 0) {
        std::swap(in, out);
    }
}

} // namespace improved

// Original blur function wrapper for benchmarking
void original_blur(const std::string& input, const std::string& output, float sigma, int passes, const std::string& policy) {
    // load image
    int width, height, channels;
    uchar* image_data = stbi_load(input.c_str(), &width, &height, &channels, 0);
    if (!image_data) {
        std::cerr << "Failed to load image: " << input << std::endl;
        return;
    }
    
    std::cout << "Source image: " << input << " " << width << "x" << height << " (" << channels << ")" << std::endl;

    // Process border policy
    Border border;
    if (policy == "mirror") border = Border::kMirror;
    else if (policy == "extend") border = Border::kExtend;
    else if (policy == "crop") border = Border::kKernelCrop;
    else if (policy == "wrap") border = Border::kWrap;
    else border = Border::kMirror;
    
    // temporary data
    std::size_t size = width * height * channels;
#ifdef USE_FLOAT
    float* new_image = new float[size];
    float* old_image = new float[size];
#else
    uchar* new_image = new uchar[size];
    uchar* old_image = new uchar[size];
#endif
    
    // channels copy r,g,b
    for(std::size_t i = 0; i < size; ++i) {
#ifdef USE_FLOAT
        old_image[i] = (float)image_data[i] / 255.f;
#else
        old_image[i] = image_data[i];
#endif
    }
    
    // stats
    auto start = std::chrono::high_resolution_clock::now();
    
    // perform gaussian blur
    fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes, border);
    
    // stats
    auto end = std::chrono::high_resolution_clock::now();
    float elapsed = std::chrono::duration_cast<std::chrono::microseconds>(end-start).count() / 1000.0f;
    std::cout << "Original Time: " << std::fixed << std::setprecision(4) << elapsed << "ms" << std::endl;

    // convert result
    for(std::size_t i = 0; i < size; ++i) {
#ifdef USE_FLOAT
        image_data[i] = (uchar)(new_image[i] * 255.f);
#else
        image_data[i] = (uchar)(new_image[i]);
#endif
    }

    // save image with "original_" prefix
    std::string output_filename = "original_" + output;
    std::string ext = output_filename.substr(output_filename.size()-3);
    if (ext == "bmp")
        stbi_write_bmp(output_filename.c_str(), width, height, channels, image_data);
    else if (ext == "jpg")
        stbi_write_jpg(output_filename.c_str(), width, height, channels, image_data, 90);
    else {
        if (ext != "png") {
            std::cout << "Image format '" << ext << "' not supported, writing default png" << std::endl;
            output_filename = output_filename.substr(0, output_filename.size()-4) + std::string(".png");
        }
        stbi_write_png(output_filename.c_str(), width, height, channels, image_data, channels*width);
    }
    
    // clean memory
    stbi_image_free(image_data);
    delete[] new_image;
    delete[] old_image;
}

// Improved blur function wrapper for benchmarking
void improved_blur(const std::string& input, const std::string& output, float sigma, int passes, const std::string& policy) {
    // load image
    int width, height, channels;
    uchar* image_data = stbi_load(input.c_str(), &width, &height, &channels, 0);
    if (!image_data) {
        std::cerr << "Failed to load image: " << input << std::endl;
        return;
    }
    
    std::cout << "Source image: " << input << " " << width << "x" << height << " (" << channels << ")" << std::endl;

    // Process border policy
    Border border;
    if (policy == "mirror") border = Border::kMirror;
    else if (policy == "extend") border = Border::kExtend;
    else if (policy == "crop") border = Border::kKernelCrop;
    else if (policy == "wrap") border = Border::kWrap;
    else border = Border::kMirror;
    
    // temporary data
    std::size_t size = width * height * channels;
#ifdef USE_FLOAT
    float* new_image = new float[size];
    float* old_image = new float[size];
#else
    uchar* new_image = new uchar[size];
    uchar* old_image = new uchar[size];
#endif
    
    // channels copy r,g,b
    for(std::size_t i = 0; i < size; ++i) {
#ifdef USE_FLOAT
        old_image[i] = (float)image_data[i] / 255.f;
#else
        old_image[i] = image_data[i];
#endif
    }
    
    // stats
    auto start = std::chrono::high_resolution_clock::now();
    
    // perform gaussian blur with improved version
    improved::fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes);
    
    // stats
    auto end = std::chrono::high_resolution_clock::now();
    float elapsed = std::chrono::duration_cast<std::chrono::microseconds>(end-start).count() / 1000.0f;
    std::cout << "Improved Time: " << std::fixed << std::setprecision(4) << elapsed << "ms" << std::endl;

    // convert result
    for(std::size_t i = 0; i < size; ++i) {
#ifdef USE_FLOAT
        image_data[i] = (uchar)(new_image[i] * 255.f);
#else
        image_data[i] = (uchar)(new_image[i]);
#endif
    }

    // save image with "improved_" prefix
    std::string output_filename = "improved_" + output;
    std::string ext = output_filename.substr(output_filename.size()-3);
    if (ext == "bmp")
        stbi_write_bmp(output_filename.c_str(), width, height, channels, image_data);
    else if (ext == "jpg")
        stbi_write_jpg(output_filename.c_str(), width, height, channels, image_data, 90);
    else {
        if (ext != "png") {
            std::cout << "Image format '" << ext << "' not supported, writing default png" << std::endl; 
            output_filename = output_filename.substr(0, output_filename.size()-4) + std::string(".png");
        }
        stbi_write_png(output_filename.c_str(), width, height, channels, image_data, channels*width);
    }
    
    // clean memory
    stbi_image_free(image_data);
    delete[] new_image;
    delete[] old_image;
}

// Benchmark function to compare performance with multiple runs
void benchmark(const std::string& input, const std::string& output, float sigma, int passes, const std::string& policy, int num_runs = 5) {
    std::vector<BenchmarkFunction> functions = {original_blur, improved_blur};
    std::vector<std::string> function_names = {"Original", "Improved"};
    
    std::vector<std::vector<float>> times(functions.size());
    
    // Run each function multiple times
    for (int i = 0; i < functions.size(); i++) {
        std::cout << "Running " << function_names[i] << " version " << num_runs << " times..." << std::endl;
        
        for (int run = 0; run < num_runs; run++) {
            // load image each time to avoid caching effects
            int width, height, channels;
            uchar* image_data = stbi_load(input.c_str(), &width, &height, &channels, 0);
            if (!image_data) {
                std::cerr << "Failed to load image: " << input << std::endl;
                continue;
            }
            
            // temporary data
            std::size_t size = width * height * channels;
#ifdef USE_FLOAT
            float* new_image = new float[size];
            float* old_image = new float[size];
#else
            uchar* new_image = new uchar[size];
            uchar* old_image = new uchar[size];
#endif
            
            // channels copy r,g,b
            for(std::size_t i = 0; i < size; ++i) {
#ifdef USE_FLOAT
                old_image[i] = (float)image_data[i] / 255.f;
#else
                old_image[i] = image_data[i];
#endif
            }
            
            // Warm up
            if (run == 0) {
                if (i == 0) {
                    fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes, Border::kMirror);
                } else {
                    improved::fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes);
                }
            }
            
            // stats
            auto start = std::chrono::high_resolution_clock::now();
            
            // perform gaussian blur
            if (i == 0) {
                fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes, Border::kMirror);
            } else {
                improved::fast_gaussian_blur(old_image, new_image, width, height, channels, sigma, passes);
            }
            
            // stats
            auto end = std::chrono::high_resolution_clock::now();
            float elapsed = std::chrono::duration_cast<std::chrono::microseconds>(end-start).count() / 1000.0f;
            times[i].push_back(elapsed);
            
            std::cout << "  Run " << run + 1 << ": " << std::fixed << std::setprecision(4) << elapsed << "ms" << std::endl;
            
            // clean memory
            stbi_image_free(image_data);
            delete[] new_image;
            delete[] old_image;
        }
    }
    
    // Calculate and print statistics
    std::cout << "\nBenchmark Results (in milliseconds):" << std::endl;
    std::cout << std::setw(10) << "Version" << std::setw(10) << "Min" << std::setw(10) << "Max" 
              << std::setw(10) << "Avg" << std::setw(15) << "Improvement" << std::endl;
    std::cout << std::string(55, '-') << std::endl;
    
    std::vector<float> averages;
    
    for (int i = 0; i < functions.size(); i++) {
        float min_time = *std::min_element(times[i].begin(), times[i].end());
        float max_time = *std::max_element(times[i].begin(), times[i].end());
        
        float sum = 0.0f;
        for (float time : times[i]) {
            sum += time;
        }
        float avg = sum / times[i].size();
        averages.push_back(avg);
        
        std::cout << std::setw(10) << function_names[i] 
                  << std::setw(10) << std::fixed << std::setprecision(2) << min_time
                  << std::setw(10) << std::fixed << std::setprecision(2) << max_time
                  << std::setw(10) << std::fixed << std::setprecision(2) << avg;
                  
        if (i > 0) {
            float improvement = (averages[0] - avg) / averages[0] * 100.0f;
            std::cout << std::setw(14) << std::fixed << std::setprecision(2) << improvement << "%";
        }
        
        std::cout << std::endl;
    }
}

int main(int argc, char* argv[])
{   
    // helper
    if (argc < 4)
    {
        printf("%s [input] [output] [sigma] [order - optional] [border - optional] [benchmark - optional]\n", argv[0]);
        printf("\n");
        printf("- input:  extension should be any of [.jpg, .png, .bmp, .tga, .psd, .gif, .hdr, .pic, .pnm].\n");
        printf("- output: extension should be any of [.png, .jpg, .bmp]. Unknown extensions will be saved as .png by default.\n");
        printf("- sigma:  Gaussian standard deviation (float). Should be positive.\n");
        printf("- order:  optional filter order [1: box, 2: bilinear, 3: biquadratic, 4. bicubic, ..., 10]. Should be positive.\n");
        printf("          Default is 3 and current implementation supports up to 10 box blur passes, but one can easily add more in the code.\n");
        printf("- border: optional treatment of image boundaries [mirror, extend, crop, wrap]. Default is mirror.\n");
        printf("- benchmark: optional flag [0, 1]. If 1, runs a benchmark comparing original and improved versions.\n");
        printf("\n");
        exit(1);
    }

    // read parameters
    const std::string input = argv[1];
    const std::string output = argv[2];
    const float sigma = std::atof(argv[3]);
    const int passes = argc > 4 ? std::atoi(argv[4]) : 3;
    const std::string policy = argc > 5 ? std::string(argv[5]) : "mirror";
    const bool run_benchmark = argc > 6 ? std::atoi(argv[6]) > 0 : false;

    if (run_benchmark) {
        // Run benchmarking with multiple iterations
        benchmark(input, output, sigma, passes, policy, 5);
    } else {
        // Run both versions once and save output images
        original_blur(input, output, sigma, passes, policy);
        improved_blur(input, output, sigma, passes, policy);
        
        std::cout << "\nImages saved with 'original_' and 'improved_' prefixes." << std::endl;
    }

    return 0;
}

